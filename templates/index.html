<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notion Backup Explorer</title>
    <link rel="stylesheet" type="text/css" href="/static/styles.css">
    <!-- Bootstrap Icons for visual cues -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
</head>
<body>
    <div class="sidebar">
        <h2>Navigation</h2>
        <ul id="sidebar-list">
            <!-- Sidebar items will be dynamically loaded here -->
        </ul>
    </div>
    <div class="main-content">
        <h1>üìÅ Notion Backup Explorer</h1>
        
        <!-- Progress Bar -->
        <div id="progress-container" class="progress-container" style="display: none;">
            <div class="progress-bar" id="progress-bar"></div>
            <span id="progress-text">0%</span>
        </div>
        
        <!-- Action Menu -->
        <div class="action-menu">
            <button class="action-button" id="actions-dropdown">Actions <i class="bi bi-chevron-down"></i></button>
            <div id="actions-menu" class="actions-menu-content">
                <button onclick="performAction('download')">Download Selected</button>
                <button onclick="performAction('delete')">Delete Selected</button>
            </div>
        </div>
        
        <!-- Breadcrumb Navigation -->
        <div class="breadcrumbs" id="breadcrumb">
            <a href="#" data-path="">Root</a>
        </div>
        
        <!-- Action Buttons, Upload, Search Bar, and Sort Dropdown -->
        <div class="action-group">
            <div class="button-group">
                <button id="download-all-button" class="download-button" onclick="downloadAll()">Download All as ZIP</button>
                <button id="upload-button" class="upload-button" onclick="document.getElementById('upload-input').click()">Upload</button>
                <input type="file" id="upload-input" style="display: none;" multiple onchange="uploadFiles()">
            </div>
            <div class="search-sort-group">
                <input type="text" id="search-bar" placeholder="Search files and folders..." oninput="searchFiles()">
                <select id="sort-dropdown" onchange="sortFiles()">
                    <option value="name_asc">Name (A-Z)</option>
                    <option value="name_desc">Name (Z-A)</option>
                    <option value="date_asc">Date Modified (Oldest)</option>
                    <option value="date_desc">Date Modified (Newest)</option>
                    <option value="size_asc">Size (Smallest)</option>
                    <option value="size_desc">Size (Largest)</option>
                </select>
            </div>
        </div>
        
        <!-- Directory and File Listing -->
        <form id="file-list-form">
            <ul class="file-list" id="file-list">
                <!-- Content will be dynamically loaded here -->
            </ul>
        </form>
    </div>

    <!-- Selected Items Side Panel -->
    <div id="selected-items-panel" class="selected-items-panel">
        <button class="close-button" onclick="closeSelectedItemsPanel()">&times;</button>
        <h3>Selected Items</h3>
        <ul id="selected-items-list">
            <!-- Selected items will be listed here -->
        </ul>
        <button class="side-panel-button" onclick="performAction('download')">Download Selected</button>
        <button class="delete-button side-panel-button" onclick="performAction('delete')">Delete Selected</button>
    </div>

    <!-- Loading Spinner -->
    <div id="loading" class="loading-overlay" style="display: none;">
        <div class="spinner"></div>
    </div>

    <script>
        let currentPath = '';
        let allDirectories = [];
        let allFiles = [];
        let currentSort = 'name_asc';
        let currentSearch = '';
        let isGlobalSearch = false; // Toggle between current directory and global search
        let selectedItems = new Set(); // To store selected item paths

        document.addEventListener('DOMContentLoaded', () => {
            loadDirectory('');
            loadSidebar();
            setupActionsDropdown();
            setupSelectedItemsPanel();
        });

        // Function to setup the Actions Dropdown Menu
        function setupActionsDropdown() {
            const actionsDropdown = document.getElementById('actions-dropdown');
            const actionsMenu = document.getElementById('actions-menu');

            actionsDropdown.addEventListener('click', (e) => {
                e.stopPropagation();
                actionsMenu.classList.toggle('show');
            });

            // Close the dropdown when clicking outside
            window.addEventListener('click', () => {
                if (actionsMenu.classList.contains('show')) {
                    actionsMenu.classList.remove('show');
                }
            });
        }

        // Function to setup the Selected Items Side Panel
        function setupSelectedItemsPanel() {
            const selectedItemsList = document.getElementById('selected-items-list');
            const fileListForm = document.getElementById('file-list-form');

            // Toggle the side panel visibility
            fileListForm.addEventListener('change', (e) => {
                if (e.target.classList.contains('file-checkbox')) {
                    const path = e.target.value;
                    if (e.target.checked) {
                        selectedItems.add(path);
                    } else {
                        selectedItems.delete(path);
                    }
                    updateSelectedItemsPanel();
                }
            });

            // Allow clicking on selected items to deselect them
            selectedItemsList.addEventListener('click', (e) => {
                if (e.target.tagName === 'LI') {
                    const path = e.target.getAttribute('data-path');
                    selectedItems.delete(path);
                    // Uncheck the corresponding checkbox
                    const checkbox = document.querySelector(`.file-checkbox[value="${path}"]`);
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                    updateSelectedItemsPanel();
                }
            });
        }

        // Function to update the Selected Items Side Panel
        function updateSelectedItemsPanel() {
            const selectedItemsList = document.getElementById('selected-items-list');
            selectedItemsList.innerHTML = '';

            selectedItems.forEach(path => {
                const listItem = document.createElement('li');
                listItem.textContent = path;
                listItem.setAttribute('data-path', path);
                selectedItemsList.appendChild(listItem);
            });

            // Show or hide the side panel based on selections
            const sidePanel = document.getElementById('selected-items-panel');
            if (selectedItems.size > 0) {
                sidePanel.style.display = 'block';
            } else {
                sidePanel.style.display = 'none';
            }
        }

        // Function to close the Selected Items Side Panel
        function closeSelectedItemsPanel() {
            selectedItems.clear();
            updateSelectedItemsPanel();
            // Uncheck all checkboxes
            const checkboxes = document.querySelectorAll('.file-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
        }

        // Function to perform actions (Download or Delete) on selected items
        function performAction(action) {
            if (selectedItems.size === 0) {
                alert('No items selected.');
                return;
            }

            const paths = Array.from(selectedItems);
            if (action === 'download') {
                downloadItems(paths);
            } else if (action === 'delete') {
                deleteItems(paths);
            }
        }

        // Consolidated Function to Download Items
        function downloadItems(paths) {
            if (paths.length === 1 && !allDirectories.includes(paths[0])) {
                // Single file download
                downloadSingleFile(paths[0]);
            } else {
                // Multiple files or directories download as ZIP
                downloadMultipleItems(paths);
            }
        }

        // Function to download a single file
        function downloadSingleFile(path) {
            showLoading(true);
            fetch('/download_selected', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ selected_paths: [path] }),
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to download the file');
                }
                return response.blob();
            })
            .then(blob => {
                const filename = path.split('/').pop();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                window.URL.revokeObjectURL(url);
            })
            .catch(error => {
                console.error('Error downloading the file:', error);
                alert('Failed to download the file.');
            })
            .finally(() => {
                showLoading(false);
            });
        }

        // Function to download multiple items as a ZIP with progress
        function downloadMultipleItems(paths) {
            showLoading(true);
            showProgress(true);
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            progressBar.style.width = '0%';
            progressText.textContent = '0%';
            progressBar.classList.remove('indeterminate');

            fetch('/download_selected', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ selected_paths: paths }),
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => { throw data; });
                }

                const contentLength = response.headers.get('Content-Length');
                if (contentLength) {
                    const total = parseInt(contentLength, 10);
                    let loaded = 0;

                    return new Response(
                        new ReadableStream({
                            start(controller) {
                                const reader = response.body.getReader();
                                function read() {
                                    reader.read().then(({ done, value }) => {
                                        if (done) {
                                            controller.close();
                                            return;
                                        }
                                        loaded += value.byteLength;
                                        const percent = ((loaded / total) * 100).toFixed(2);
                                        progressBar.style.width = `${percent}%`;
                                        progressText.textContent = `${percent}%`;
                                        controller.enqueue(value);
                                        read();
                                    }).catch(error => {
                                        console.error('Error reading stream:', error);
                                        controller.error(error);
                                    });
                                }
                                read();
                            }
                        })
                    );
                } else {
                    // If Content-Length is not provided, show an indeterminate progress bar
                    progressBar.classList.add('indeterminate');
                    progressText.textContent = 'Downloading...';
                    return response.blob();
                }
            })
            .then(response => {
                if (response instanceof Blob) {
                    const disposition = response.headers ? response.headers.get('Content-Disposition') : null;
                    let filename = 'download.zip';
                    if (disposition && disposition.indexOf('filename=') !== -1) {
                        const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
                        const matches = filenameRegex.exec(disposition);
                        if (matches != null && matches[1]) { 
                            filename = matches[1].replace(/['"]/g, '');
                        }
                    }
                    const url = window.URL.createObjectURL(response);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    window.URL.revokeObjectURL(url);
                    alert('Download completed successfully.');
                }
            })
            .catch(error => {
                console.error('Error downloading selected items:', error);
                alert(error.error || 'An error occurred while downloading the selected items.');
            })
            .finally(() => {
                showLoading(false);
                showProgress(false);
                // Remove indeterminate class if present
                const progressBar = document.getElementById('progress-bar');
                progressBar.classList.remove('indeterminate');
            });
        }

        // Function to delete items
        function deleteItems(paths) {
            if (!confirm(`Are you sure you want to delete ${paths.length} item(s)? This action cannot be undone.`)) {
                return;
            }

            showLoading(true);
            fetch('/delete', {  // Ensure this endpoint matches the backend route
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ path: paths }), // Send array
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => { throw data; });
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    alert(data.error);
                } else {
                    if (data.errors && data.errors.length > 0) {
                        let message = 'Some items were not deleted:\n';
                        data.errors.forEach(err => {
                            message += `- ${err.path}: ${err.error}\n`;
                        });
                        alert(message);
                    } else {
                        alert('Items deleted successfully.');
                    }
                    selectedItems.clear();
                    updateSelectedItemsPanel();
                    loadDirectory(currentPath); // Refresh the directory view
                }
                showLoading(false);
            })
            .catch(error => {
                console.error('Error deleting items:', error);
                alert(error.error || 'An error occurred while deleting the items.');
                showLoading(false);
            });
        }

        // Function to load directory contents
        function loadDirectory(path) {
            currentPath = path;
            isGlobalSearch = false; // Reset to current directory search
            document.getElementById('search-bar').value = ''; // Clear search bar
            showLoading(true);
            fetch(`/api/list?path=${encodeURIComponent(path)}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(data.error);
                        showLoading(false);
                        return;
                    }
                    allDirectories = data.directories.map(dir => {
                        // Construct relative path
                        return path ? `${path}/${dir}`.replace(/\\/g, '/') : dir;
                    });
                    allFiles = data.files;
                    updateBreadcrumb(data.breadcrumb);
                    applyFilters();
                    showLoading(false);
                })
                .catch(error => {
                    console.error('Error fetching directory:', error);
                    alert('An error occurred while loading the directory.');
                    showLoading(false);
                });
        }

        // Function to load sidebar navigation
        function loadSidebar() {
            fetch('/api/list?path=')
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        console.error('Error loading sidebar:', data.error);
                        return;
                    }
                    const sidebarList = document.getElementById('sidebar-list');
                    sidebarList.innerHTML = '';
                    data.directories.forEach(directory => {
                        const fullPath = directory; // Relative path
                        const listItem = document.createElement('li');
                        const link = document.createElement('a');
                        link.href = '#';
                        link.textContent = directory.split('/').pop(); // Display only the directory name
                        link.setAttribute('data-path', fullPath);
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            const newPath = fullPath;
                            loadDirectory(newPath);
                        });
                        listItem.appendChild(link);
                        sidebarList.appendChild(listItem);
                    });
                })
                .catch(error => {
                    console.error('Error loading sidebar:', error);
                });
        }

        // Function to update breadcrumb navigation
        function updateBreadcrumb(breadcrumb) {
            const breadcrumbDiv = document.getElementById('breadcrumb');
            breadcrumbDiv.innerHTML = ''; // Clear existing breadcrumbs
            breadcrumb.forEach((crumb, index) => {
                const link = document.createElement('a');
                link.href = '#';
                link.textContent = crumb.name;
                link.setAttribute('data-path', crumb.path);
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const newPath = crumb.path;
                    loadDirectory(newPath);
                });
                breadcrumbDiv.appendChild(link);
                if (index < breadcrumb.length - 1) {
                    const separator = document.createTextNode(' / ');
                    breadcrumbDiv.appendChild(separator);
                }
            });
        }

        // Function to update the file and directory list based on search and sort
        function applyFilters() {
            if (isGlobalSearch && currentSearch.trim() !== '') {
                // Use the global search results directly without performing another search
                updateFileList(allDirectories, allFiles);
                return;
            }

            let filteredDirectories = allDirectories.filter(dir => dir.toLowerCase().includes(currentSearch.toLowerCase()));
            let filteredFiles = allFiles.filter(file => file.name.toLowerCase().includes(currentSearch.toLowerCase()));

            // Sort directories and files separately
            filteredDirectories = sortArray(filteredDirectories, 'name_asc', 'directory'); // Directories sorted by name ascending
            filteredFiles = sortArray(filteredFiles, currentSort, 'file'); // Files sorted based on currentSort

            updateFileList(filteredDirectories, filteredFiles);
        }

        // Sorting function
        function sortArray(arr, sortType, type='directory') {
            let sortedArr = [...arr]; // Clone the array to avoid in-place sorting
            if (type === 'directory') {
                if (sortType.startsWith('name')) {
                    sortedArr.sort((a, b) => {
                        if (a.toLowerCase() < b.toLowerCase()) return sortType === 'name_asc' ? -1 : 1;
                        if (a.toLowerCase() > b.toLowerCase()) return sortType === 'name_asc' ? 1 : -1;
                        return 0;
                    });
                }
                // Add more sorting types for directories if needed
            } else if (type === 'file') {
                if (sortType.startsWith('name')) {
                    sortedArr.sort((a, b) => {
                        if (a.name.toLowerCase() < b.name.toLowerCase()) return sortType === 'name_asc' ? -1 : 1;
                        if (a.name.toLowerCase() > b.name.toLowerCase()) return sortType === 'name_asc' ? 1 : -1;
                        return 0;
                    });
                } else if (sortType.startsWith('date')) {
                    sortedArr.sort((a, b) => {
                        let aDate = new Date(a.lastModified * 1000); // Assuming lastModified is a Unix timestamp in seconds
                        let bDate = new Date(b.lastModified * 1000);
                        if (aDate < bDate) return sortType === 'date_asc' ? -1 : 1;
                        if (aDate > bDate) return sortType === 'date_asc' ? 1 : -1;
                        return 0;
                    });
                } else if (sortType.startsWith('size')) {
                    sortedArr.sort((a, b) => {
                        if (a.size < b.size) return sortType === 'size_asc' ? -1 : 1;
                        if (a.size > b.size) return sortType === 'size_asc' ? 1 : -1;
                        return 0;
                    });
                }
            }
            return sortedArr;
        }

        // Function to update the file and directory list
        function updateFileList(directories, files) {
            const fileList = document.getElementById('file-list');
            fileList.innerHTML = ''; // Clear existing list

            // Add directories
            directories.forEach(directory => {
                const listItem = document.createElement('li');
                listItem.className = 'file-list-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.name = 'selected_paths';
                checkbox.value = directory; // Use the full relative path
                checkbox.className = 'file-checkbox';
                if (selectedItems.has(directory)) {
                    checkbox.checked = true;
                }

                const link = document.createElement('a');
                link.href = '#';
                link.className = 'file-link';
                link.innerHTML = `<i class="bi bi-folder-fill file-icon"></i> ${getDirectoryName(directory)}`; // Display only the directory name
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const newPath = directory; // Use the full path directly
                    loadDirectory(newPath);
                });

                // File details (e.g., Folder)
                const details = document.createElement('div');
                details.className = 'file-details';
                details.textContent = 'Folder';

                listItem.appendChild(checkbox);
                listItem.appendChild(link);
                listItem.appendChild(details);
                fileList.appendChild(listItem);
            });

            // Add files
            files.forEach(file => {
                const listItem = document.createElement('li');
                listItem.className = 'file-list-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.name = 'selected_paths';
                checkbox.value = file.path; // Use the full path provided by the backend
                checkbox.className = 'file-checkbox';
                if (selectedItems.has(file.path)) {
                    checkbox.checked = true;
                }

                const span = document.createElement('span');
                span.className = 'file-link';
                span.innerHTML = `<i class="bi bi-file-earmark-fill file-icon"></i> ${file.name}`;
                span.addEventListener('click', () => {
                    // Optionally, implement file preview or download
                });

                // File details (e.g., size and last modified)
                const details = document.createElement('div');
                details.className = 'file-details';
                details.textContent = `${formatSize(file.size)} | ${formatDate(file.lastModified)}`;

                listItem.appendChild(checkbox);
                listItem.appendChild(span);
                listItem.appendChild(details);
                fileList.appendChild(listItem);
            });
        }

        // Helper Function to Extract Directory Name from Path
        function getDirectoryName(path) {
            const parts = path.split('/');
            return parts[parts.length - 1];
        }

        // Function to format file size
        function formatSize(bytes) {
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            if (bytes === 0) return '0 Byte';
            const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
            return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
        }

        // Function to format date
        function formatDate(timestamp) {
            const date = new Date(timestamp * 1000); // Convert Unix timestamp to milliseconds
            return date.toLocaleString();
        }

        // Function to search files and folders (current directory and globally)
        function searchFiles() {
            const query = document.getElementById('search-bar').value.trim();
            currentSearch = query;
            if (query === '') {
                isGlobalSearch = false;
                applyFilters();
                return;
            }

            // Treat any search input as a global search
            isGlobalSearch = true;
            showLoading(true);
            performGlobalSearch(query);
        }

        // Function to perform global search (recursive search)
        function performGlobalSearch(query) {
            fetch(`/api/search?query=${encodeURIComponent(query)}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(data.error);
                        showLoading(false);
                        return;
                    }
                    allDirectories = data.directories;
                    allFiles = data.files;
                    updateBreadcrumb(data.breadcrumb); // Update breadcrumbs to show 'Search Results'
                    applyFilters();
                    showLoading(false);
                })
                .catch(error => {
                    console.error('Error performing search:', error);
                    alert('An error occurred while searching.');
                    showLoading(false);
                });
        }

        // Function to sort files and folders
        function sortFiles() {
            const sortType = document.getElementById('sort-dropdown').value;
            currentSort = sortType;
            applyFilters();
        }

        // Function to download all files as a ZIP with progress
        function downloadAll() {
            showLoading(true);
            showProgress(true);
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            progressBar.style.width = '0%';
            progressText.textContent = '0%';
            progressBar.classList.remove('indeterminate');

            fetch('/download_all')
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(data => { throw data; });
                    }

                    const contentLength = response.headers.get('Content-Length');
                    if (contentLength) {
                        const total = parseInt(contentLength, 10);
                        let loaded = 0;

                        return new Response(
                            new ReadableStream({
                                start(controller) {
                                    const reader = response.body.getReader();
                                    function read() {
                                        reader.read().then(({ done, value }) => {
                                            if (done) {
                                                controller.close();
                                                return;
                                            }
                                            loaded += value.byteLength;
                                            const percent = ((loaded / total) * 100).toFixed(2);
                                            progressBar.style.width = `${percent}%`;
                                            progressText.textContent = `${percent}%`;
                                            controller.enqueue(value);
                                            read();
                                        }).catch(error => {
                                            console.error('Error reading stream:', error);
                                            controller.error(error);
                                        });
                                    }
                                    read();
                                }
                            })
                        );
                    } else {
                        // If Content-Length is not provided, show an indeterminate progress bar
                        progressBar.classList.add('indeterminate');
                        progressText.textContent = 'Downloading...';
                        return response.blob();
                    }
                })
                .then(response => {
                    if (response instanceof Blob) {
                        const disposition = response.headers ? response.headers.get('Content-Disposition') : null;
                        let filename = 'download.zip';
                        if (disposition && disposition.indexOf('filename=') !== -1) {
                            const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
                            const matches = filenameRegex.exec(disposition);
                            if (matches != null && matches[1]) { 
                                filename = matches[1].replace(/['"]/g, '');
                            }
                        }
                        const url = window.URL.createObjectURL(response);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        window.URL.revokeObjectURL(url);
                        alert('Download completed successfully.');
                    }
                })
                .catch(error => {
                    console.error('Error downloading all items:', error);
                    alert(error.error || 'An error occurred while downloading all items.');
                })
                .finally(() => {
                    showLoading(false);
                    showProgress(false);
                    // Remove indeterminate class if present
                    const progressBar = document.getElementById('progress-bar');
                    progressBar.classList.remove('indeterminate');
                });
        }

        // Function to upload files
        function uploadFiles() {
            const input = document.getElementById('upload-input');
            const files = input.files;
            if (files.length === 0) {
                return;
            }

            const formData = new FormData();
            for (let i = 0; i < files.length; i++) {
                formData.append('files', files[i]);
            }
            formData.append('path', currentPath);

            showLoading(true);
            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert(data.error);
                } else {
                    alert('Files uploaded successfully.');
                    loadDirectory(currentPath); // Refresh the directory view
                }
                showLoading(false);
            })
            .catch(error => {
                console.error('Error uploading files:', error);
                alert('An error occurred while uploading files.');
                showLoading(false);
            });

            // Reset the input
            input.value = '';
        }

        // Function to show or hide the loading spinner
        function showLoading(show) {
            const loadingDiv = document.getElementById('loading');
            if (show) {
                loadingDiv.style.display = 'flex';
            } else {
                loadingDiv.style.display = 'none';
            }
        }

        // Function to show or hide the progress bar
        function showProgress(show) {
            const progressContainer = document.getElementById('progress-container');
            if (show) {
                progressContainer.style.display = 'block';
            } else {
                progressContainer.style.display = 'none';
            }
        }
    </script>
</body>
</html>
